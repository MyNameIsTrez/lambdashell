#+TITLE: MINISHELL

* Install GNU readline
** Arch Linux
+ 1. sudo pacman -S readline
** Debian
+ 1. sudo apt-get install -y readline-common
+ 2. sudo apt-get install libreadline-dev
** MacOS
+ 1. rm -rf $HOME/.brew && curl -fsSL https://rawgit.com/kube/42homebrew/master/install.sh | zs
+ 2. brew install readline

* Include GNU readline
** Debian
+ -lreadline -lncurses
** macOS
+ -L ~/.brew/opt/readline/lib -l readline -I ~/.brew/opt/readline/include

* Minishell
** Parsing:
I would imagine parsing to be one of the areas of the project
with the most amount of edge cases, hence heavy testing is required here.
Comparison with bash will be very useful in this case.
*** TODO Expansion: [2/3]
+ [X] Recognise names of ENV variables.
+ [X] Print value of recognized environment variables.
+ [ ] Be able to use variables as input.
*** TODO Tokenization: [0/3]
+ [ ] Pipeline for converting strings to tokens.
+ [ ] Mapping tokens to set of common piping and execution instructions.

** Builtins
*** TODO echo
*** TODO cd
*** TODO pwd
*** TODO export
*** TODO unset
*** TODO env
*** TODO exit

** Redirections & execution
[ NOTE: I've merged redirection and execution due to one being useless without the other. ]

I imagine the best way to handle pipes is to create interoperable
"blks" consisting of a command to execute, and two mutable IO fields.
Theoretically a function could be made which prepares the command to be executed.
As arguments, the environment, the executable, and IO file descriptors.
If the input for the file descriptors is NULL, then the default STDIN/STDOUT file
descriptors shall be used.
*** DONE CMD type [3/3]
+ [X] cmd type
+ [X] cmd constructor
+ [X] cmd deallocator
*** TODO Pipe blks [3/4]
+ [X] blk type
+ [X] blk constructor
+ [X] blk deallocator
+ [ ] blk combiner (linked list?)
*** TODO Executor [0/2]
+ [ ] blk executor
+ [ ] Process monitor

* Logbook
Minishell can basically be divided into several "parts".
	1. Parsing
	2. Recreation of builtin functions
	3. Redirections (i.e. pipes, file descriptors, heredoc, etc.)
	4. Execution (i.e. forking, command running, etc.)