#+TITLE: MINISHELL

* Install GNU readline
** Arch Linux
+ 1. sudo pacman -S readline
** Debian
+ 1. sudo apt-get install -y readline-common
+ 2. sudo apt-get install libreadline-dev
** MacOS
+ 1. rm -rf $HOME/.brew && curl -fsSL https://rawgit.com/kube/42homebrew/master/install.sh | zs
+ 2. brew install readline
** Include readline (at compile-time) [MacOS]
-L ~/.brew/opt/readline/lib -l readline -I ~/.brew/opt/readline/include

* Minishell Architecture
An idea for how minishell should be structured.
** Graph:
    This stage takes raw input from the commandline.
    And places a prompt when finished.
    Before passing it on to the parsing stage.
+----------------------+
| INPUT (GNU readline) |
+----------------------+
    ↓
    ↓ The parsing stage takes a string of text
    ↓ and converts it to a series of tokens or meanings.
    ↓ For an example, take the string "cat streng-geheim.txt | grep "blanke frank" > output_file"
    ↓ This would become (pipe_blk redirection file) with pipe blk defined as (cmd_one, cmd_two)
    ↓
+---------+
| PARSING |
+---------+
    ↓
    ↓ Other than sounding like a list written by Stalin, the execution list is essentially
    ↓ an instruction for our next cold blooded component, the executor.
    ↓ The execution list in form of essence is by species a linked list
    ↓ with a few important variables, int type, which is an integer representing the type
    ↓ of the element i.e. :
    ↓     singular commands (t_cmd),
    ↓     pipe blocks (t_pipe_blk),
    ↓     redirections (unimplemented).
    ↓     builtins (umimplemented)
    ↓     files (who needs those? just stick everything in ram like javascript developers.)
    ↓
+-----------+
| EXEC_LIST |
+-----------+
    ↓
    ↓ The executor is a function which takes as input the exec_list (defined in structs.h)
    ↓ With full knowledge of the list it will setup pipes, fork, dup2, and fulfill other
    ↓ preparations before takeoff.
    ↓
+----------+
| EXECUTOR |
+----------+

* Minishell
** Parsing:
I would imagine parsing to be one of the areas of the project
with the most amount of edge cases, hence heavy testing is required here.
Comparison with bash will be very useful in this case.
*** TODO Expansion: [2/3]
+ [X] Recognise names of ENV variables.
+ [X] Print value of recognized environment variables.
+ [ ] Be able to use variables as input.
*** TODO Tokenization: [0/3]
+ [ ] Pipeline for converting strings to tokens.
+ [ ] Mapping tokens to set of common piping and execution instructions.

** Builtins
*** TODO echo
*** TODO cd
*** TODO pwd
*** TODO export
*** TODO unset
*** TODO env
*** TODO exit

** Redirections & execution
[ NOTE: I've merged redirection and execution due to one being useless without the other. ]

I imagine the best way to handle pipes is to create interoperable
"blocks" consisting of a command to execute, and two mutable IO fields.
Theoretically a function could be made which prepares the command to be executed.
As arguments, the environment, the executable, and IO file descriptors.
If the input for the file descriptors is NULL, then the default STDIN/STDOUT file
descriptors shall be used.
*** DONE CMD type [3/3]
+ [X] cmd type
+ [X] cmd constructor
+ [X] cmd deallocator
*** TODO Pipe Blocks [3/4]
+ [X] block type
+ [X] block constructor
+ [X] block deallocator
+ [ ] block combiner (linked list?)
*** TODO Executor [0/2]
+ [ ] Block executor
+ [ ] Process monitor

* Logbook
Minishell can basically be divided into several "parts".
	1. Parsing
	2. Recreation of builtin functions
	3. Redirections (i.e. pipes, file descriptors, heredoc, etc.)
	4. Execution (i.e. forking, command running, etc.)

What has not been done:
	Assuming the above categories, parts 3 and 4, have not been touched
	at all. Of part 2, only a very simple builtin command has been recreated,
	namely pwd. Part 2 can perhaps be considered a stand-alone part that can be
	picked up anything.

	Most of my time has been spent on parsing (part 1). In short, nothing has
	been done with pipes, file descriptors and commands.
	But I did lay the groundwork for that...

What has been done:
-	A lot of things to get us started quickly on minishell. Especially parts 3 and 4.
-	Makefile that includes the readline library required for reading command line input.
	The Makefile is also made such that we can quickly check for memory leaks
	via fsanitize. Run "make leaks" to compile minishell with -g3 -fsanitize=address.
-	Consequently, everything that has been done so far has been constantly checked for
	memory leaks. Still, proper function protection and consequent clean-up, is not
	finished.
-	During everything I tried to keep in mind the norm. The only aspect where I
	ignored the norm was with regards with the number of functions in a single
	source file. I did this simply for keeping a clear overview of what has
	currently already been done without making it a spider's web through which
	we need to navigate. It makes it also more easy to detect and solve memory leaks.
	At the end we could simply divide the functions in the source files into separate
	files to conform to the norm.
- 	Implemented data structures that can be used throughout the project. It is based on
	the advice I received from talking with lots of students that are way ahead of us.
-	Functions that can be used to copy over the system env into memory for use in our shell.
	This "copied env" is stored as a linked list, where each node contains a key and value
	char array, and also a void pointer to the next node. I get back to this later below.
	This env should be mutable on the fly and various tools have been coded for this.
-	Most of my hours went into parsing (part 1), which can be divided into sub sections.
	For proper preparation for the execution of commands, the input parsing steps
	below have been done in successive order.
	0.	[prompting] Prompting the user with an input line prompt.
	1.	[storing] Storing the input line as a char array.
	2.	[checking] Checking the input line for correct syntax.
	3.	[expander] Expanding the variables in the input line. This demanded a
		lot of work, and is the main reason I opted for working with a linked list
		with key value pairs for storing the system environment variables.

		While iterating over the input line, it checks for the presence of
		variables (i.e. "$<var_name>"). If found, it extracts the "var_name"
		and looks it up in our env linked list by comparing "var_name" with each
		node's "key" value. When found, it retrieves the corresponding key's
		"value" value. I have coded many functions that can be used for
		various practical purposes when working with our environment.
		Such as:
			(1) completely deleting an env variable entry on the basis of its key value alone
			(2) easily changing a key's value with only the key name and the desired value
			(3) obtaining a key's value with the key's name alone.
			The latter (point 3) is especially useful for the [expansion] part.
	4.	[line_tokenizer] Basically, cutting up the expanded input line into separate
		words. These words are stored in a "tokens" linked list, where each node
		holds two values: [1] the value of the token, and [2] the "type" of the token.
		Here, value refers to simply the word that has been cut out from the expanded line,
		(i.e. char array), whereas the type refers to what "kind" of token it is.
		I distinguish between (1) string, (2) read, (3) write, (4) pipe, (5) heredoc and (6) append tokens.
