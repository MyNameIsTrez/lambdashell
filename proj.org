#+TITLE: Minishell

* TODO Will [/]
+ [ ] Write ft_fprintf for easy error printing.
+ [ ] License builtin as advised by the GNU GPLv3.

* Minishell
** TODO Builtins: [3/7]
+ [X] cd
+ [X] pwd
+ [X] env
+ [ ] exit
+ [ ] echo with -n
+ [ ] export
+ [ ] unset
** TODO Features: [3/10]
+ [X] Redirections
+ [X] Piping
+ [X] Single commands
+ [ ] Variable expansion
+ [ ] Return values
+ [ ] Signals
+ [ ] History
+ [ ] Single quotes
+ [ ] Double quotes
+ [ ] Parsing

* Methodology
** How bash does it (Thanks Freek!)
1. split on pipes
2. set environment variables found in the command (VAR=VALUE cmd)
3. set up the redirections (heredoc is part of that)
4. expand environment variables
5. parse the commands
6. check if it is built-in, if not find the executable, if so, run built-in
7. execute all commands at the same time (and if one doesn't expect input and the one that pipes into the non-expecting-input one tries to pipe into there, it should quit also (`cat | ls`))

** Results of studying bash source code
*** Redirection
Internally bash represents redirections using a sruct containing the following:
1. A pointer to the next redirection.
2. A redirectee union which contains either a:
   1. A destination integer (likely referring to a file descriptor.)
   2. A null terminated string referring to a word.
3.  flags for open()
4.  An enum referring to the type of redirection.
5. A char containg the end of file as defined by the potential heredoc.
#+NAME: redirec (bash)
#+BEGIN_SRC c
typedef struct redirect {
  struct redirect *next; /* Next element, or NULL. */
  REDIRECTEE redirector; /* Descriptor or varname to be redirected. */
  int rflags; /* Private flags for this redirection */
  int flags; /* Flag value for `open'. */
  enum r_instruction  instruction; /* What to do with the information. */
  REDIRECTEE redirectee; /* File descriptor or filename */
  char *here_doc_eof; /* The word that appeared in <<foo. */
} REDIRECT;
#+END_SRC

*** simple_cmd (Bog standard exec binary command)
The representation of a cmd is as follows:
#+NAME: simple_com (bash)
#+BEGIN_SRC c
typedef struct simple_com {
  int flags; /* See description of CMD flags. */
  int line; /* line number the command starts on */
  WORD_LIST *words; /* The program name, the arguments, variable assignments, etc. */
  REDIRECT *redirects; /* Redirections to perform. */
} SIMPLE_COM;
#+END_SRC

* Documentation
** t_cmd
The t_cmd struct contains all data required to run execve.
Can also contain builtins.
** t_exec_element
A multifunctional struct that is filled out through the course of the program.
#+BEGIN_SRC c
typedef struct s_exec_element
{
    int  type; // I.e. tkn_bltin, tkn_cmd.
    char *line; // Contains the raw line: "grep "Hello!" file.txt"
    void *value; // Contains the struct required for execution: t_cmd
    struct s_exec_element *next; // Next element in the list.
}   t_exec_element;
#+END_SRC

* t_vector
A doubly linked list with a number of subroutines for easy
manipulation and navigation.
** t_vector *alloc_vector(int n_elements);
Allocates (n_elements) vector elements.
** int vec_assign_element(t_vector *head, size_t idx, void *data);
Takes the head of the list, an index value and a pointer to data.
The vector element at (idx) will have its data value point to data.
** t_vector *vec_get_element(t_vector *head, size_t idx);
Returns the vector element at (idx).
** t_vector *new_vector_element(t_vector *prev, size_t idx);
Returns a new vector element.
** void *free_vector(t_vector *vec, void (*dealloc) (void *));
Deallocs entire vector list.
** t_vector *vector_get_last(t_vector *vec);
Returns last element in vector.
** t_vector *vector_get_first(t_vector *vec);
Returns first element in vector.
** int vector_size(t_vector *vec);
Returns size of vector.
** t_vector *vector_push_back(t_vector *head, t_vector *new);
Places new vector element at the back of the vector.
** void vector_pop_back(t_vector *head, void (*dealloc) (void *));
Removes the vector element from back of the vector.
** t_vector *vector_push_front(t_vector **head, t_vector *new);
Pushes new vector element to the front of the vector.
** t_vector *vector_pop_front(t_vector *head, void (*dealloc) (void *));
Removes vector element from the front of the vector.
